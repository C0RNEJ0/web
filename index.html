<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reproductor con segundos + letra sincronizada</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      margin: 0; padding: 2rem; line-height: 1.5;
      display: grid; place-items: center; min-height: 100dvh;
      background: rgba(0,0,0,0.02);
    }
    .card {
      width: min(820px, 95vw);
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 16px;
      padding: 1.25rem;
      box-shadow: 0 8px 30px rgba(0,0,0,0.08);
      background: #fff;
    }
    h1 { font-size: 1.25rem; margin: 0 0 0.25rem 0; }
    p { margin: 0.25rem 0; }
    audio { width: 100%; margin-top: 0.5rem; }
    .row { display: flex; gap: 0.6rem; align-items: center; flex-wrap: wrap; margin-top: 0.75rem; }
    button {
      border: 0; border-radius: 999px; padding: 0.6rem 1rem; cursor: pointer;
      background: #111; color: #fff; font-weight: 600;
    }
    .muted-note { font-size: 0.9rem; opacity: 0.85; }
    .status { margin-top: 0.5rem; font-size: 0.95rem; }
    .timer { font-variant-numeric: tabular-nums; font-weight: 600; }
    .playlist { list-style: none; padding: 0; margin: 1rem 0 0 0; }
    .track {
      display: grid; grid-template-columns: 1fr auto; gap: 0.5rem;
      padding: 0.6rem 0.75rem; border-radius: 12px; cursor: pointer;
      border: 1px solid rgba(0,0,0,0.08);
    }
    .track:hover { background: rgba(0,0,0,0.04); }
    .track.active { outline: 2px solid #1a73e8; background: rgba(26,115,232,0.08); }
    .dur { opacity: 0.8; font-variant-numeric: tabular-nums; }
    .progress-wrap { margin-top: 0.5rem; }
    .progress {
      width: 100%; height: 8px; background: rgba(0,0,0,0.08);
      border-radius: 999px; overflow: hidden; position: relative;
    }
    .bar { height: 100%; width: 0%; background: #1a73e8; transition: width 0.08s linear; }
    .labels { display: flex; justify-content: space-between; margin-top: 0.35rem; font-variant-numeric: tabular-nums; }

    /* Letra / karaoke */
    .lyrics {
      margin-top: 1rem;
      border: 1px dashed rgba(0,0,0,0.2);
      border-radius: 12px;
      padding: 1rem;
      background: rgba(0,0,0,0.03);
    }
    .lyric-line {
      font-size: clamp(1.05rem, 2.5vw, 1.4rem);
      font-weight: 700;
      text-align: center;
      letter-spacing: 0.3px;
    }
    .lyric-sub {
      opacity: 0.8;
      font-size: 0.95rem;
      text-align: center;
      margin-top: 0.25rem;
      font-variant-numeric: tabular-nums;
    }

    @media (prefers-color-scheme: dark) {
      body { background: #0b0b0c; }
      .card { background: #121214; border-color: rgba(255,255,255,0.08); }
      button { background: #e7e7e7; color: #111; }
      .progress { background: rgba(255,255,255,0.12); }
      .bar { background: #8ab4f8; }
      .lyrics {
        background: rgba(255,255,255,0.04);
        border-color: rgba(255,255,255,0.12);
      }
    }
  </style>
</head>
<body>
  <main class="card">
    <h1>Reproductor de audio</h1>
    <p class="muted-note">Autoplay con sonido est√° bloqueado por el navegador; inicia en silencio. Usa ‚ÄúActivar sonido‚Äù o cualquier clic/tecla.</p>

    <!-- Reproductor principal (usa el id 'meuAudio' como en tu snippet) -->
    <audio id="meuAudio" preload="auto" controls autoplay muted></audio>

    <div class="row">
      <button id="unmuteBtn" type="button">üîä Activar sonido</button>
      <button id="playPauseBtn" type="button">‚èØÔ∏è Reproducir / Pausar</button>
      <button id="muteToggleBtn" type="button">ü§´ Silenciar / Sonar</button>
    </div>

    <!-- Barra de progreso + tiempos en mm:ss y en segundos -->
    <div class="progress-wrap">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="labels">
        <span>Actual: <span id="curMMSS" class="timer">00:00</span> (<span id="curS">0</span> s)</span>
        <span>Total: <span id="totMMSS" class="timer">00:00</span> (<span id="totS">0</span> s)</span>
      </div>
    </div>

    <p id="status" class="status">Cargando audio‚Ä¶</p>

    <!-- Lista de canciones con duraci√≥n (mm:ss y segundos) -->
    <h2 style="margin-top:1rem;font-size:1.05rem">Lista</h2>
    <ul id="playlist" class="playlist"></ul>

    <!-- Letra sincronizada -->
    <section class="lyrics">
      <div id="lyricLine" class="lyric-line">‚Äî</div>
      <div id="lyricSub" class="lyric-sub">00:00 ‚Äî 00:00 (0 s)</div>
    </section>
  </main>

  <script>
    // ======= Tu arreglo de frases (duracao en milisegundos) =======
    const frases = [
      { texto: "...", duracao: 1750 },
      { texto: "I", duracao: 350 },
      { texto: "wanna", duracao: 400 },
      { texto: "da-", duracao: 400 },
      { texto: "I", duracao: 350 },
      { texto: "wanna", duracao: 400 },
      { texto: "dance", duracao: 400 },
      { texto: "in", duracao: 200 },
      { texto: "the", duracao: 200 },
      { texto: "lights", duracao: 800 },
      { texto: "...", duracao: 500 },

      { texto: "I", duracao: 300 },
      { texto: "wanna", duracao: 400 },
      { texto: "ro-", duracao: 300 },
      { texto: "I", duracao: 300 },
      { texto: "wanna", duracao: 400 },
      { texto: "rock", duracao: 400 },
      { texto: "your", duracao: 500 },
      { texto: "body", duracao: 1150 },

      { texto: "I", duracao: 300 },
      { texto: "wanna", duracao: 400 },
      { texto: "go", duracao: 300 },
      { texto: "I", duracao: 300 },
      { texto: "wanna", duracao: 400 },
      { texto: "go", duracao: 300 },
      { texto: "for", duracao: 350 },
      { texto: "a", duracao: 300 },
      { texto: "ride", duracao: 800 },
      { texto: "...", duracao: 400 },

      { texto: "Hop", duracao: 400 },
      { texto: "in", duracao: 250 },
      { texto: "the", duracao: 250 },
      { texto: "music", duracao: 500 },
      { texto: "and", duracao: 350 },
      { texto: "rock", duracao: 450 },
      { texto: "your", duracao: 500 },
      { texto: "body", duracao: 700 },
      { texto: "right", duracao: 400 },

      { texto: "Rock", duracao: 300 },
      { texto: "that", duracao: 200 },
      { texto: "body", duracao: 300 },
      { texto: "come on", duracao: 250 },
      { texto: "come on", duracao: 150 },
      { texto: "come on come on", duracao: 250 },
      { texto: "come on come on", duracao: 150 },
      { texto: "rock", duracao: 300 },
      { texto: "that", duracao: 200 },
      { texto: "body", duracao: 300 },
      { texto: "rock", duracao: 300 },
      { texto: "that", duracao: 200 },
      { texto: "body", duracao: 500 },
      { texto: "...", duracao: 200000 }
    ];

    // ======= Utilidades de tiempo =======
    function pad(n) { return String(Math.floor(n)).padStart(2, '0'); }
    function toMMSS(secs) {
      if (!isFinite(secs) || secs < 0) return '00:00';
      const m = Math.floor(secs / 60);
      const s = Math.floor(secs % 60);
      return pad(m) + ':' + pad(s);
    }
    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    // ======= Playlist =======
    const tracks = [
      {
        title: 'V√≠deo sem t√≠tulo',
        sources: ['V√≠deo-sem-t√≠tulo.mp3', 'video-sem-titulo.mp3'],
        duration: NaN,
        resolvedSrc: null
      }
    ];

    // ======= Elementos =======
    const audio = document.getElementById('meuAudio');
    const statusEl = document.getElementById('status');
    const unmuteBtn = document.getElementById('unmuteBtn');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const muteToggleBtn = document.getElementById('muteToggleBtn');
    const playlistEl = document.getElementById('playlist');
    const bar = document.getElementById('bar');
    const curMMSS = document.getElementById('curMMSS');
    const curS    = document.getElementById('curS');
    const totMMSS = document.getElementById('totMMSS');
    const totS    = document.getElementById('totS');

    const lyricLine = document.getElementById('lyricLine');
    const lyricSub  = document.getElementById('lyricSub');

    function setStatus(msg) { if (statusEl) statusEl.textContent = msg; }

    // ======= Letra sincronizada (pre-c√°lculo) =======
    const cueStartMs = []; // inicio de cada frase en ms
    (function buildCues(){
      let acc = 0;
      for (const f of frases) { cueStartMs.push(acc); acc += (Number(f.duracao) || 0); }
    })();
    const totalLyricsMs = cueStartMs.length ? cueStartMs[cueStartMs.length - 1] + (Number(frases.at(-1).duracao)||0) : 0;

    function findPhraseIndex(tMs) {
      // Busca el √∫ltimo cue cuyo inicio <= tMs
      let i = 0;
      // Como la lista no es enorme, un lineal es suficiente; si quisieras, cambia a binaria.
      for (let k = 0; k < cueStartMs.length; k++) {
        if (cueStartMs[k] <= tMs) i = k; else break;
      }
      return i;
    }

    function updateLyricsDisplay(tMs) {
      const i = findPhraseIndex(tMs);
      const start = cueStartMs[i] || 0;
      const end = (i < cueStartMs.length - 1) ? cueStartMs[i + 1] : totalLyricsMs;
      const segStart = start / 1000;
      const segEnd   = end   / 1000;

      lyricLine.textContent = frases[i]?.texto ?? '‚Äî';
      lyricSub.textContent  = `${toMMSS(segStart)} ‚Äî ${toMMSS(segEnd)} (${Math.max(0, Math.round(segEnd - segStart))} s)`;
    }

    // ======= UI Playlist =======
    function renderPlaylist(activeIndex = 0) {
      playlistEl.innerHTML = '';
      tracks.forEach((t, i) => {
        const li = document.createElement('li');
        li.className = 'track' + (i === activeIndex ? ' active' : '');
        li.dataset.index = i;

        const title = document.createElement('div');
        title.textContent = t.title;

        const dur = document.createElement('div');
        dur.className = 'dur';
        const d = t.duration;
        dur.textContent = isFinite(d) ? `${toMMSS(d)} (${Math.round(d)} s)` : '‚Äî:‚Äî (‚Ä¶ s)';

        li.appendChild(title);
        li.appendChild(dur);
        li.addEventListener('click', async () => {
          document.querySelectorAll('.track').forEach(el => el.classList.remove('active'));
          li.classList.add('active');
          await loadTrack(i, /*autoplay*/ true);
        });
        playlistEl.appendChild(li);
      });
    }

    function resolveSrcForTrack(track) {
      return new Promise((resolve) => {
        if (track.resolvedSrc) return resolve(track.resolvedSrc);
        const candidates = [...track.sources];
        const test = new Audio(); test.preload = 'metadata';

        const tryNext = () => {
          const src = candidates.shift();
          if (!src) return resolve(null);
          test.src = src;
          const onLoaded = () => { cleanup(); track.resolvedSrc = src; resolve(src); };
          const onError  = () => { cleanup(); tryNext(); };
          function cleanup(){
            test.removeEventListener('loadedmetadata', onLoaded);
            test.removeEventListener('error', onError);
          }
          test.addEventListener('loadedmetadata', onLoaded, { once: true });
          test.addEventListener('error', onError, { once: true });
          test.load();
        };
        tryNext();
      });
    }

    async function loadTrack(index, autoplay = false) {
      const track = tracks[index];
      setStatus('Cargando audio‚Ä¶');
      const src = await resolveSrcForTrack(track);
      if (!src) { setStatus('No se pudo resolver la fuente. Revisa el nombre del archivo.'); return; }

      audio.src = src;
      audio.load();

      audio.addEventListener('loadedmetadata', () => {
        updateTotals();
        setStatus(audio.muted ? 'Listo (silenciado).' : 'Listo con sonido.');
      }, { once: true });

      if (autoplay) {
        try {
          // Aqu√≠ integramos tu intenci√≥n de: document.getElementById('meuAudio').play();
          await audio.play();
          setStatus(audio.muted ? 'Reproduciendo (silenciado)‚Ä¶' : 'Reproduciendo con sonido ‚úÖ');
        } catch (e) {
          setStatus('Autoplay bloqueado hasta interacci√≥n del usuario.');
        }
      }
      renderPlaylist(index);
      // Al cargar una pista nueva, reinicia la letra
      updateLyricsDisplay(0);
    }

    // ======= Carga de duraciones de cada m√∫sica =======
    function preloadDurations() {
      tracks.forEach((t, i) => {
        if (isFinite(t.duration)) return;
        const candidates = [...t.sources];
        const aux = new Audio(); aux.preload = 'metadata';

        const tryNext = () => {
          const src = candidates.shift();
          if (!src) { renderPlaylist(getActiveIndex()); return; }
          aux.src = src;
          const onMeta = () => {
            cleanup(); t.duration = aux.duration; if (!t.resolvedSrc) t.resolvedSrc = src;
            renderPlaylist(getActiveIndex());
          };
          const onError = () => { cleanup(); tryNext(); };
          function cleanup(){
            aux.removeEventListener('loadedmetadata', onMeta);
            aux.removeEventListener('error', onError);
          }
          aux.addEventListener('loadedmetadata', onMeta);
          aux.addEventListener('error', onError);
          aux.load();
        };
        tryNext();
      });
    }

    function getActiveIndex() {
      const active = playlistEl.querySelector('.track.active');
      if (!active) return 0; return Number(active.dataset.index) || 0;
    }

    // ======= Controles =======
    unmuteBtn.addEventListener('click', async () => {
      audio.muted = false;
      try { await audio.play(); setStatus('Reproduciendo con sonido ‚úÖ'); }
      catch (e) { setStatus('No se pudo iniciar la reproducci√≥n.'); }
    });

    playPauseBtn.addEventListener('click', async () => {
      try {
        if (audio.paused) {
          await audio.play();
          setStatus(audio.muted ? 'Reproduciendo (silenciado)‚Ä¶' : 'Reproduciendo con sonido ‚úÖ');
        } else {
          audio.pause();
          setStatus('Pausado ‚è∏Ô∏è');
        }
      } catch (e) { setStatus('No se pudo cambiar el estado de reproducci√≥n.'); }
    });

    muteToggleBtn.addEventListener('click', () => {
      audio.muted = !audio.muted;
      setStatus(audio.muted ? 'Silenciado ü§´' : 'Con sonido üîä');
    });

    // ======= Progreso y tiempos =======
    function updateTotals() {
      const d = audio.duration;
      totMMSS.textContent = toMMSS(d);
      totS.textContent = isFinite(d) ? Math.round(d) : 0;
    }
    function updateCurrent() {
      const t = audio.currentTime, d = audio.duration;
      curMMSS.textContent = toMMSS(t);
      curS.textContent = Math.round(t);
      const pct = isFinite(d) && d > 0 ? (t / d) : 0;
      bar.style.width = (clamp01(pct) * 100).toFixed(2) + '%';

      // Actualiza la letra seg√∫n el tiempo actual del audio
      updateLyricsDisplay(t * 1000);
    }

    audio.addEventListener('timeupdate', updateCurrent);
    audio.addEventListener('loadedmetadata', () => { updateTotals(); updateCurrent(); });

    // ======= Desbloqueo por interacci√≥n (autoplay policies) =======
    async function startOnce() {
      audio.muted = false;
      try { await audio.play(); setStatus('Reproduciendo con sonido ‚úÖ'); }
      catch { /* ignorar; el usuario puede usar los botones */ }
      window.removeEventListener('click', startOnce);
      window.removeEventListener('keydown', startOnce);
      window.removeEventListener('touchstart', startOnce);
    }
    window.addEventListener('click', startOnce, { once: true });
    window.addEventListener('keydown', startOnce, { once: true });
    window.addEventListener('touchstart', startOnce, { once: true });

    // Si el usuario hace seek o vuelve a 0, re-calculamos la l√≠nea
    audio.addEventListener('seeking', () => updateLyricsDisplay(audio.currentTime * 1000));
    audio.addEventListener('seeked',  () => updateLyricsDisplay(audio.currentTime * 1000));
    audio.addEventListener('ended',   () => updateLyricsDisplay(totalLyricsMs));

    // ======= Inicio =======
    (async function init() {
      renderPlaylist(0);
      preloadDurations();
      await loadTrack(0, /*autoplay*/ true);
    })();
  </script>
</body>
</html>
